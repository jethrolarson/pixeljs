// Generated by CoffeeScript 1.3.3
(function() {

  window.Game = {
    gameMode: 'play',
    dragMode: 'break',
    isDragging: false,
    isErasing: false,
    mute: false,
    colWidth: 40,
    MAX_CELL_WIDTH: 60,
    lastCell: '',
    init: function($game) {
      var canvas;
      this.$game = $game;
      this.$gridCell = this.$game.find('#gridCell');
      this.$win = this.$game.find('#win');
      this.$lose = this.$game.find('#lose');
      this.$score = this.$game.find('#score');
      this.$games = this.$game.find('#games');
      this.$colHints = this.$game.find('#colHints');
      this.$rowHints = this.$game.find('#rowHints');
      this.$layers = $('#layers');
      this.$canvas = $('#canvas');
      this.$colorSheet = $(document.createElement('style')).prependTo(this.$game);
      this.$game.trigger('init');
      canvas = document.getElementById('canvas');
      this.loadAssets();
      this.bindEvents();
      return this;
    },
    start: function() {
      return this.loadGame(window.level);
    },
    blip: 0,
    drawGrid: function() {
      var i, _i, _j, _ref, _ref1;
      this.p.stroke(this.p.brightness(this.bgc) > 80 ? 0 : 200);
      for (i = _i = 1, _ref = this.level.x; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        if (i % 5) {
          this.p.strokeWeight(1);
        } else {
          this.p.strokeWeight(3);
        }
        this.p.line(i * this.cw + this.gridBounds.x1, this.gridBounds.y1, i * this.cw + this.gridBounds.x1, this.level.y * this.cw + this.gridBounds.y1);
      }
      for (i = _j = 1, _ref1 = this.level.y; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        if (i % 5) {
          this.p.strokeWeight(1);
        } else {
          this.p.strokeWeight(3);
        }
        this.p.line(this.gridBounds.x1, i * this.cw + this.gridBounds.y1, this.level.x * this.cw + this.gridBounds.x1, i * this.cw + this.gridBounds.y1);
      }
      return this.p.fill(0, 102, 153);
    },
    drawCell: function(x, y) {
      var cellMargin;
      cellMargin = 0;
      return this.p.rect(x * this.cw + this.gridBounds.x1 + cellMargin, y * this.cw + this.gridBounds.y1 + cellMargin, this.cw - cellMargin * 2, this.cw - cellMargin * 2);
    },
    drawCells: function() {
      var fgc, layer, layerIndex, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2;
      this.p.noStroke();
      _ref = this.level.layers;
      for (layerIndex = _i = 0, _len = _ref.length; _i < _len; layerIndex = ++_i) {
        layer = _ref[layerIndex];
        fgc = color.hexToRGB(layer.fgcolor);
        for (x = _j = 0, _ref1 = this.level.x; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          for (y = _k = 0, _ref2 = this.level.y; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
            if (this.gameMode === 'play') {
              if (+layer.mark[y][x]) {
                this.p.fill(100, 0, 0);
                this.drawCell(x, y);
              }
              if (+layer.paint[y][x]) {
                this.p.fill(fgc.r, fgc.g, fgc.b);
                this.drawCell(x, y);
              }
            } else {
              if (layer.visible && +layer.grid.getAt(x, y)) {
                this.p.fill(fgc.r, fgc.g, fgc.b);
                this.drawCell(x, y);
              }
            }
          }
        }
      }
      return this;
    },
    draw: function() {
      var cell, curCell, gridH, gridW, gridX, gridY, x, xw, y, yw;
      this.p.background(80);
      gridW = this.w - this.gridBounds.x1 - (this.w - this.gridBounds.x2);
      xw = Math.floor(gridW / this.level.x);
      gridH = this.h - this.gridBounds.y1 - (this.h - this.gridBounds.y2);
      yw = Math.floor(gridH / this.level.y);
      this.cw = Math.min(xw, yw);
      gridW = this.cw * this.level.x;
      gridH = this.cw * this.level.y;
      this.bgc = color.hexToRGB(this.level.bgcolor);
      this.bgc = this.p.color(this.bgc.r, this.bgc.g, this.bgc.b);
      this.p.fill(this.bgc);
      this.p.rect(this.gridBounds.x1, this.gridBounds.y1, gridW, gridH);
      gridX = Math.floor((this.p.mouseX - this.gridBounds.x1) / this.cw);
      gridY = Math.floor((this.p.mouseY - this.gridBounds.y1) / this.cw);
      curCell = gridX + ',' + gridY;
      x = gridX * this.cw;
      y = gridY * this.cw;
      this.p.text(gridX + ',' + gridY, 10, 10);
      if (this.p.mouseX > this.gridBounds.x1 && this.p.mouseY > this.gridBounds.y1 && gridX < this.level.x && gridY < this.level.y) {
        if (this.p.mouseIsPressed) {
          if (this.gameMode === 'play') {
            this.dragMode = this.p.mouseButton === this.p.RIGHT ? 'mark' : 'grid';
            if (this.newlyPressed && this.dragMode === 'mark') {
              this.isErasing = +this.level.currentLayer.marks.getAt(gridX, gridY);
            }
            if (this.dragMode === 'mark') {
              this.level.currentLayer.mark.setAt(gridX, gridY, !this.isErasing, 'paint');
            } else {
              this.level.currentLayer.paint.setAt(gridX, gridY, "1", 'paint');
            }
          } else {
            cell = +this.level.currentLayer.grid.getAt(gridX, gridY);
            if (this.newlyPressed) {
              this.isErasing = !!cell;
            }
            if (!!cell !== !this.isErasing) {
              this.level.currentLayer.grid.setAt(gridX, gridY, (+(!this.isErasing)).toString());
              if (this.lastCell !== curCell || this.newlyPressed) {
                this.assets.bing.play();
              }
            }
          }
        } else {
          if (this.lastCell !== curCell) {
            this.assets.hoverSound.play();
          }
        }
      }
      this.newlyPressed = false;
      this.drawCells();
      this.drawGrid();
      this.p.fill(20, 80, 200, 50);
      this.lastCell = curCell;
      return this;
    },
    edit: function() {
      this.gameMode = 'edit';
      this.$gridCell.enableContext();
      this.assets.paint = new SoundGroup('paint.wav');
      return this.start();
    },
    getCol: function(x) {
      return this.getGrid().find("li:nth-child(" + this.level.x + "n+" + (x + 2) + ")");
    },
    getRow: function(y) {
      return this.getGrid().find('li').slice(y * this.level.x, (y + 1) * this.level.x);
    },
    getCoord: function(el) {
      var index;
      index = $(el).parent().children('li').index(el);
      return {
        x: index % this.level.x,
        y: Math.floor(index / this.level.x)
      };
    },
    isGameComplete: function() {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.level.y; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (!this.isLineComplete(this.getRow(i))) {
          return false;
        }
      }
      return true;
    },
    isLineComplete: function($line) {
      var cell, coord, _i, _len;
      for (_i = 0, _len = $line.length; _i < _len; _i++) {
        cell = $line[_i];
        coord = this.getCoord(cell);
        if (this.level.getAt(coord.x, coord.y) && !$(cell).hasClass('on')) {
          return false;
        }
      }
      return true;
    },
    updateCols: function(cols) {
      var delta;
      delta = cols - this.level.x;
      if (delta > 0) {
        this.level.addCols(delta);
      } else if (delta < 0) {
        this.level.subtractCols(Math.abs(delta));
      }
      return this.renderLevel();
    },
    updateRows: function(cols) {
      var delta;
      delta = cols - this.level.y;
      if (delta > 0) {
        this.level.addRows(delta);
      } else if (delta < 0) {
        this.level.subtractRows(Math.abs(delta));
      }
      return this.renderLevel();
    },
    renderHints: function() {
      var hint, hintGroup, html, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
      html = '';
      _ref = this.level.getColHints();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hintGroup = _ref[_i];
        html += '<li>';
        for (_j = 0, _len1 = hintGroup.length; _j < _len1; _j++) {
          hint = hintGroup[_j];
          html += '<div>' + hint + '</div>';
        }
        html += '</li>';
      }
      this.$colHints.html(html);
      html = '';
      _ref1 = this.level.getRowHints();
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        hintGroup = _ref1[_k];
        html += '<li>';
        for (_l = 0, _len3 = hintGroup.length; _l < _len3; _l++) {
          hint = hintGroup[_l];
          html += '<div>' + hint + '</div>';
        }
        html += '</li>';
      }
      return this.$rowHints.html(html);
    },
    renderLayerUI: function() {
      var i, layer, layerUI, _i, _len, _ref;
      layerUI = '';
      _ref = this.level.layers;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        layer = _ref[i];
        layerUI += "<div>\n<input \n	class=\"changeLayer layer" + i + " " + (i === this.level.currentLayerIndex ? 'on' : '') + "\"\n	type=\"color\" name=\"fgcolor" + i + "\" value=\"" + layer.fgcolor + "\" style=\"background-color:" + layer.fgcolor + "\"/>\n<a class=\"layerVisibility\" href=\"#layer" + i + "\">&#9635;</a>\n</div>";
      }
      if (this.gameMode !== 'play') {
        layerUI += '<button id="addLayer" type="button">+</button>';
      }
      return this.$layers.html(layerUI);
    },
    loadGame: function(level) {
      this.level = Level(level);
      this.renderLevel();
      this.renderLayerUI();
      return this.updateScore();
    },
    getGrid: function(layerIndex) {
      if (layerIndex == null) {
        layerIndex = this.level.currentLayerIndex;
      }
      return $('#layer_' + layerIndex);
    },
    renderLevel: function() {
      var _this = this;
      this.w = window.innerWidth;
      this.h = window.innerHeight;
      this.gridBounds = {
        x1: 10,
        y1: 10,
        x2: this.w - 20,
        y2: this.h - 30
      };
      new Processing(canvas, function(p) {
        _this.p = p;
        _this.p.width = _this.w;
        _this.p.height = _this.h;
        _this.p.draw = _this.draw.bind(_this);
        _this.p.frameRate(24);
        _this.p.mousePressed = function() {
          _this.newlyPressed = true;
          return _this.p.mouseIsPressed = true;
        };
        return _this.p.mouseReleased = function() {
          return _this.p.mouseIsPressed = false;
        };
      });
      if (this.gameMode === 'play') {
        this.score = 0;
        $('#title').html(this.level.title);
        $('#par').text("Par: " + this.level.par);
        this.updateHints();
        return this.renderHints();
      }
    },
    loadAssets: function() {
      return this.assets = {
        hoverSound: new SoundGroup('grid_hover.wav'),
        boom: new SoundGroup('boom.wav'),
        bing: new SoundGroup('bing.wav'),
        mark: new SoundGroup('mark.wav'),
        win: new Audio('win.wav')
      };
    },
    addLayer: function() {
      this.level.addLayer();
      this.renderLayerUI();
      return this.renderLevel();
    },
    changeLayer: function(layer) {
      this.level.setLayer(layer);
      this.$gridCell.find('ul').removeClass('on');
      this.getGrid().addClass('on');
      if (this.gameMode === 'play') {
        return this.renderHints();
      }
    },
    bindEvents: function() {
      var that,
        _this = this;
      this.$game.bind({
        "break": $.proxy(this.eBreak, this),
        mark: $.proxy(this.eMark, this),
        lose: $.proxy(this.eLose, this),
        win: $.proxy(this.eWin, this),
        erase: $.proxy(this.eErase, this),
        die: function() {
          _this.score += 1;
          _this.$game.addClass('shake');
          if (!_this.mute) {
            _this.assets.boom.play();
          }
          _this.updateScore();
          return setTimeout(function() {
            return _this.$game.removeClass('shake');
          }, 300);
        }
      });
      $('#mute').bind('change', function(e) {
        _this.mute = e.target.checked;
        return true;
      });
      that = this;
      $('.changeLayer').live('click', function(e) {
        var layerRE;
        layerRE = /layer(\d)+/.exec(this.className);
        if (layerRE.length) {
          that.changeLayer(+layerRE[1]);
          if (!$(this).hasClass('on')) {
            $('.changeLayer').removeClass('on');
            $(this).addClass('on');
            return e.preventDefault();
          }
        }
      });
      return $('.layerVisibility').live('click', function(e) {
        var layerIndex, layerRE;
        e.preventDefault();
        layerRE = /^#layer(\d)+/.exec(this.hash);
        if (layerRE.length) {
          layerIndex = +layerRE[1];
          that.level.layers[layerIndex].visible = !that.level.layers[layerIndex].visible;
        }
        return true;
      });
    },
    getGolfScore: function() {
      var label, par;
      par = this.score - this.level.par;
      label = '';
      if (this.score === 0) {
        return label = 'Ace!';
      } else if (par <= -3) {
        return label = 'Albatross!';
      } else if (par === -2) {
        return label = 'Eagle!';
      } else if (par === -1) {
        return label = 'Birdie';
      } else if (par === 0) {
        return label = 'Par';
      } else if (par === 1) {
        return label = "Bogey";
      } else if (par === 2) {
        return label = "Double Bogey";
      } else if (par === 3) {
        return label = "Tripple Bogey";
      } else if (par > 3) {
        return label = this.score + " over par";
      }
    },
    updateScore: function() {
      if (this.gameMode === 'play') {
        return this.$score.text("Faults: " + this.score);
      }
    },
    eBreak: function(e, el) {
      var $el, coord;
      $el = $(el);
      if (this.gameMode === 'edit' || $el.hasClass('mark')) {
        return;
      }
      coord = this.getCoord(el);
      if (this.level.getAt(coord.x, coord.y)) {
        $el.addClass('on');
        this.updateHints();
        if (this.isGameComplete()) {
          return this.$game.trigger('win');
        } else {
          if (!this.mute) {
            return this.assets.bing.play();
          }
        }
      } else if (!$el.hasClass('error')) {
        $el.addClass('error');
        return this.$game.trigger('die', el);
      }
    },
    updateHints: function() {},
    eWin: function() {
      this.dragMode = null;
      if (!this.mute) {
        this.assets.win.play();
      }
      this.$win.text(this.getGolfScore());
      this.$win.show();
      return localStorage[this.title] = true;
    }
  };

}).call(this);
