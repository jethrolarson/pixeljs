// Generated by CoffeeScript 1.3.3
(function() {

  window.Game = {
    gameMode: 'play',
    dragMode: 'break',
    isDragging: false,
    isErasing: false,
    mute: false,
    colWidth: 40,
    MAX_CELL_WIDTH: 60,
    lastCell: '',
    init: function($game) {
      var canvas;
      this.$game = $game;
      this.$gridCell = this.$game.find('#gridCell');
      this.$win = this.$game.find('#win');
      this.$lose = this.$game.find('#lose');
      this.$score = this.$game.find('#score');
      this.$games = this.$game.find('#games');
      this.$colHints = this.$game.find('#colHints');
      this.$rowHints = this.$game.find('#rowHints');
      this.$layers = this.$game.find('#layers');
      this.$canvas = $('#canvas');
      this.$colorSheet = $(document.createElement('style')).prependTo(this.$game);
      this.$game.trigger('init');
      canvas = document.getElementById('canvas');
      this.loadAssets();
      this.bindEvents();
      return this;
    },
    start: function() {
      return this.loadGame(window.level);
    },
    blip: 0,
    drawGrid: function() {
      var i, _i, _j, _ref, _ref1;
      this.p.stroke(this.p.brightness(this.bgc) > 80 ? 0 : 200);
      for (i = _i = 1, _ref = this.level.x; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        if (i % 5) {
          this.p.strokeWeight(1);
        } else {
          this.p.strokeWeight(3);
        }
        this.p.line(i * this.cw + this.gridBounds.x1, this.gridBounds.y1, i * this.cw + this.gridBounds.x1, this.level.y * this.cw + this.gridBounds.y1);
      }
      for (i = _j = 1, _ref1 = this.level.y; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        if (i % 5) {
          this.p.strokeWeight(1);
        } else {
          this.p.strokeWeight(3);
        }
        this.p.line(this.gridBounds.x1, i * this.cw + this.gridBounds.y1, this.level.x * this.cw + this.gridBounds.x1, i * this.cw + this.gridBounds.y1);
      }
      return this.p.fill(0, 102, 153);
    },
    drawCell: function(x, y) {
      var cellMargin;
      cellMargin = 0;
      return this.p.rect(x * this.cw + this.gridBounds.x1 + cellMargin, y * this.cw + this.gridBounds.y1 + cellMargin, this.cw - cellMargin * 2, this.cw - cellMargin * 2);
    },
    drawCells: function() {
      var cell, cellx, celly, col, fgc, layer, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3;
      this.p.noStroke();
      _ref = this.level.layers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        fgc = color.hexToRGB(this.level.getLayerColor());
        this.p.fill(fgc.r, fgc.g, fgc.b);
        if (this.gameMode === 'play') {
          _ref1 = layer.paint;
          for (celly = _j = 0, _len1 = _ref1.length; _j < _len1; celly = ++_j) {
            col = _ref1[celly];
            for (cellx = _k = 0, _len2 = col.length; _k < _len2; cellx = ++_k) {
              cell = col[cellx];
              if (+cell) {
                this.drawCell(cellx, celly);
              }
            }
          }
          _ref2 = layer.mark;
          for (celly = _l = 0, _len3 = _ref2.length; _l < _len3; celly = ++_l) {
            col = _ref2[celly];
            for (cellx = _m = 0, _len4 = col.length; _m < _len4; cellx = ++_m) {
              cell = col[cellx];
              if (+cell) {
                this.p.fill(100, 0, 0);
                this.drawCell(cellx, celly);
              }
            }
          }
        } else {
          _ref3 = layer.grid;
          for (celly = _n = 0, _len5 = _ref3.length; _n < _len5; celly = ++_n) {
            col = _ref3[celly];
            for (cellx = _o = 0, _len6 = col.length; _o < _len6; cellx = ++_o) {
              cell = col[cellx];
              if (+cell) {
                this.drawCell(cellx, celly);
              }
            }
          }
        }
      }
      return this;
    },
    draw: function() {
      var curCell, gridH, gridW, gridX, gridY, x, xw, y, yw;
      this.p.background(80);
      gridW = this.w - this.gridBounds.x1 - (this.w - this.gridBounds.x2);
      xw = Math.floor(gridW / this.level.x);
      gridH = this.h - this.gridBounds.y1 - (this.h - this.gridBounds.y2);
      yw = Math.floor(gridH / this.level.y);
      this.cw = Math.min(xw, yw);
      gridW = this.cw * this.level.x;
      gridH = this.cw * this.level.y;
      this.bgc = color.hexToRGB(this.level.bgcolor);
      this.bgc = this.p.color(this.bgc.r, this.bgc.g, this.bgc.b);
      this.p.fill(this.bgc);
      this.p.rect(this.gridBounds.x1, this.gridBounds.y1, gridW, gridH);
      gridX = Math.floor((this.p.mouseX - this.gridBounds.x1) / this.cw);
      gridY = Math.floor((this.p.mouseY - this.gridBounds.y1) / this.cw);
      curCell = gridX + ',' + gridY;
      x = gridX * this.cw;
      y = gridY * this.cw;
      this.p.text(gridX + ',' + gridY, 10, 10);
      if (this.p.mouseX > this.gridBounds.x1 && this.p.mouseY > this.gridBounds.y1 && gridX < this.level.x && gridY < this.level.y) {
        if (this.p.mouseIsPressed) {
          if (this.gameMode === 'play') {
            this.dragMode = this.p.mouseButton === this.p.RIGHT ? 'mark' : 'grid';
            if (this.newlyPressed && this.dragMode === 'mark') {
              this.isErasing = this.level.currentLayer.marks[gridX][gridY];
            }
            this.level.setAt(gridX, gridY, +(!this.isErasing), 'paint');
          } else {
            this.dragMode = 'paint';
            if (this.newlyPressed) {
              this.isErasing = this.level.getAt(gridX, gridY);
            }
            this.level.setAt(gridX, gridY, +(!this.isErasing));
          }
          if (this.lastCell !== curCell) {
            this.assets.bing.play();
          }
        } else {
          if (this.lastCell !== curCell) {
            this.assets.hoverSound.play();
          }
        }
      }
      this.newlyPressed = false;
      this.drawCells();
      this.drawGrid();
      this.p.fill(20, 80, 200, 50);
      this.lastCell = curCell;
      return this;
    },
    edit: function() {
      this.gameMode = 'edit';
      this.$gridCell.enableContext();
      this.assets.paint = new SoundGroup('paint.wav');
      return this.start();
    },
    getCol: function(x) {
      return this.getGrid().find("li:nth-child(" + this.level.x + "n+" + (x + 2) + ")");
    },
    getRow: function(y) {
      return this.getGrid().find('li').slice(y * this.level.x, (y + 1) * this.level.x);
    },
    getCoord: function(el) {
      var index;
      index = $(el).parent().children('li').index(el);
      return {
        x: index % this.level.x,
        y: Math.floor(index / this.level.x)
      };
    },
    isGameComplete: function() {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.level.y; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (!this.isLineComplete(this.getRow(i))) {
          return false;
        }
      }
      return true;
    },
    isLineComplete: function($line) {
      var cell, coord, _i, _len;
      for (_i = 0, _len = $line.length; _i < _len; _i++) {
        cell = $line[_i];
        coord = this.getCoord(cell);
        if (this.level.getAt(coord.x, coord.y) && !$(cell).hasClass('on')) {
          return false;
        }
      }
      return true;
    },
    updateCols: function(cols) {
      var delta;
      delta = cols - this.level.x;
      if (delta > 0) {
        this.level.addCols(delta);
      } else if (delta < 0) {
        this.level.subtractCols(Math.abs(delta));
      }
      return this.renderLevel();
    },
    updateRows: function(cols) {
      var delta;
      delta = cols - this.level.y;
      if (delta > 0) {
        this.level.addRows(delta);
      } else if (delta < 0) {
        this.level.subtractRows(Math.abs(delta));
      }
      return this.renderLevel();
    },
    renderHints: function() {
      var hint, hintGroup, html, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
      html = '';
      _ref = this.level.getColHints();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hintGroup = _ref[_i];
        html += '<li>';
        for (_j = 0, _len1 = hintGroup.length; _j < _len1; _j++) {
          hint = hintGroup[_j];
          html += '<div>' + hint + '</div>';
        }
        html += '</li>';
      }
      this.$colHints.html(html);
      html = '';
      _ref1 = this.level.getRowHints();
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        hintGroup = _ref1[_k];
        html += '<li>';
        for (_l = 0, _len3 = hintGroup.length; _l < _len3; _l++) {
          hint = hintGroup[_l];
          html += '<div>' + hint + '</div>';
        }
        html += '</li>';
      }
      return this.$rowHints.html(html);
    },
    renderLayerUI: function() {
      var i, layer, layerUI, _i, _len, _ref;
      layerUI = '';
      _ref = this.level.layers;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        layer = _ref[i];
        layerUI += "<div>\n<a href=\"#layer" + i + "\" class=\"changeLayer layer" + i + " " + (i === this.level.currentLayerIndex ? 'on' : '') + "\">&nbsp;</a>\n<input type=\"color\" name=\"fgcolor" + i + "\" value=\"" + (this.level.getLayerColor(i)) + "\" style=\"background-color:" + (this.level.getLayerColor(i)) + "\"/>\n<a class=\"layerVisibility\" href=\"#layer" + i + "\">|</a>\n</div>";
      }
      if (this.gameMode !== 'play') {
        layerUI += '<button id="addLayer" type="button">+</button>';
      }
      return this.$layers.html(layerUI);
    },
    loadGame: function(level) {
      this.level = Level(level);
      this.renderLevel();
      this.renderLayerUI();
      return this.updateScore();
    },
    getGrid: function(layerIndex) {
      if (layerIndex == null) {
        layerIndex = this.level.currentLayerIndex;
      }
      return $('#layer_' + layerIndex);
    },
    renderLevel: function() {
      var cell, cells, html, i, isOn, layer, layerhtml, paint, _i, _j, _len, _ref,
        _this = this;
      this.w = window.innerWidth;
      this.h = window.innerHeight;
      this.gridBounds = {
        x1: 10,
        y1: 10,
        x2: this.w - 20,
        y2: this.h - 30
      };
      new Processing(canvas, function(p) {
        _this.p = p;
        _this.p.width = _this.w;
        _this.p.height = _this.h;
        _this.p.draw = _this.draw.bind(_this);
        _this.p.frameRate(24);
        _this.p.mousePressed = function() {
          _this.newlyPressed = true;
          return _this.p.mouseIsPressed = true;
        };
        return _this.p.mouseReleased = function() {
          return _this.p.mouseIsPressed = false;
        };
      });
      html = '';
      cells = this.level.x * this.level.y;
      _ref = this.level.layers;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        layer = _ref[i];
        layerhtml = '';
        for (cell = _j = 0; 0 <= cells ? _j < cells : _j > cells; cell = 0 <= cells ? ++_j : --_j) {
          if (this.gameMode !== 'play' && +layer[cell]) {
            paint = ' class="paint"';
          } else {
            paint = '';
          }
          layerhtml += "<li" + paint + "> </li>";
        }
        isOn = i === this.level.currentLayerIndex ? 'on' : '';
        html += "<ul id='layer_" + i + "' class='" + isOn + "'>" + layerhtml + "</ul>";
      }
      this.$gridCell.html(html);
      if (this.gameMode === 'play') {
        this.score = 0;
        $('#title').html(this.level.title);
        $('#par').text("Par: " + this.level.par);
        this.renderHints();
      }
      this.updateStyles();
      this.updateHints();
      return this.$gridCell.append(this.getGrid());
    },
    updateStyles: function() {
      var css, fontSize, gridHeight, gridWidth, i, layer, _i, _len, _ref;
      css = '';
      this.colWidth = Math.min(Math.floor(this.$gridCell.width() / this.level.x), this.MAX_CELL_WIDTH);
      gridWidth = this.colWidth * this.level.x;
      gridHeight = this.colWidth * this.level.y;
      fontSize = Math.min(this.colWidth * .7, 20);
      css += "#gridCell ul li{\n	width: " + this.colWidth + "px;\n	height: " + this.colWidth + "px;\n}\n#gridCell ul{\n	width: " + gridWidth + "px;\n}\n#win,#lose{\n	width: " + gridWidth + "px;\n	height: " + gridHeight + "px;\n	line-height: " + gridHeight + "px;\n}\n#rowHints,\n#colHints{\n	font-size: " + fontSize + "px;\n}\n#rowHints li,\n#rowHints li div{\n	height: " + this.colWidth + "px;\n	line-height: " + this.colWidth + "px;\n}\n#colHints li div{\n	width: " + this.colWidth + "px;\n}";
      _ref = this.level.layers;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        layer = _ref[i];
        css += "	#gridCell ul#layer_" + i + " .paint, \n	#gridCell ul#layer_" + i + " .on,\n	#game .changeLayer.layer" + i + "{\n		background-color:" + (this.level.getLayerColor(i)) + "\n}";
      }
      if (this.level.bgcolor) {
        css += "#gridCell ul:first-child{background-color: " + this.level.bgcolor + "}";
      }
      return this.$colorSheet.html('').html(css);
    },
    loadAssets: function() {
      return this.assets = {
        hoverSound: new SoundGroup('grid_hover.wav'),
        boom: new SoundGroup('boom.wav'),
        bing: new SoundGroup('bing.wav'),
        mark: new SoundGroup('mark.wav'),
        win: new Audio('win.wav')
      };
    },
    addLayer: function() {
      this.level.addLayer();
      this.renderLayerUI();
      return this.renderLevel();
    },
    changeLayer: function(layer) {
      this.level.setLayer(layer);
      this.$gridCell.find('ul').removeClass('on');
      this.getGrid().addClass('on');
      if (this.gameMode === 'play') {
        return this.renderHints();
      }
    },
    bindEvents: function() {
      var that,
        _this = this;
      this.$gridCell.disableContext().delegate('li', {
        'mouseover': $.proxy(this.eGridMouseover, this),
        'touchmove': $.proxy(this.eGridTouchmove, this),
        'mousedown touchstart': $.proxy(this.eGridMousedown, this)
      });
      this.$game.bind({
        "break": $.proxy(this.eBreak, this),
        mark: $.proxy(this.eMark, this),
        lose: $.proxy(this.eLose, this),
        win: $.proxy(this.eWin, this),
        paint: $.proxy(this.ePaint, this),
        erase: $.proxy(this.eErase, this),
        die: function() {
          _this.score += 1;
          _this.$game.addClass('shake');
          if (!_this.mute) {
            _this.assets.boom.play();
          }
          _this.updateScore();
          return setTimeout(function() {
            return _this.$game.removeClass('shake');
          }, 300);
        }
      });
      $('#mute').bind('change', function(e) {
        _this.mute = e.target.checked;
        return true;
      });
      $(document).bind({
        mouseup: function() {
          return _this.isDragging = false;
        }
      });
      that = this;
      $('.changeLayer').live('click', function() {
        var layerRE;
        layerRE = /^#layer(\d)+/.exec(this.hash);
        if (layerRE.length) {
          that.changeLayer(+layerRE[1]);
          $('.changeLayer').removeClass('on');
          return $(this).addClass('on');
        }
      });
      return $('.layerVisibility').live('click', function(e) {
        var layer, layerRE, layerVisibility;
        e.preventDefault();
        layerRE = /^#layer(\d)+/.exec(this.hash);
        if (layerRE.length) {
          layer = +layerRE[i];
          layerVisibility = this.level.getLayerVisibility(layer);
          return this.level.setLayerVisibility(layer, !layerVisibility);
        }
      });
    },
    getGolfScore: function() {
      var label, par;
      par = this.score - this.level.par;
      label = '';
      if (this.score === 0) {
        return label = 'Ace!';
      } else if (par <= -3) {
        return label = 'Albatross!';
      } else if (par === -2) {
        return label = 'Eagle!';
      } else if (par === -1) {
        return label = 'Birdie';
      } else if (par === 0) {
        return label = 'Par';
      } else if (par === 1) {
        return label = "Bogey";
      } else if (par === 2) {
        return label = "Double Bogey";
      } else if (par === 3) {
        return label = "Tripple Bogey";
      } else if (par > 3) {
        return label = this.score + " over par";
      }
    },
    updateScore: function() {
      if (this.gameMode === 'play') {
        return this.$score.text("Faults: " + this.score);
      }
    },
    eBreak: function(e, el) {
      var $el, coord;
      $el = $(el);
      if (this.gameMode === 'edit' || $el.hasClass('mark')) {
        return;
      }
      coord = this.getCoord(el);
      if (this.level.getAt(coord.x, coord.y)) {
        $el.addClass('on');
        this.updateHints();
        if (this.isGameComplete()) {
          return this.$game.trigger('win');
        } else {
          if (!this.mute) {
            return this.assets.bing.play();
          }
        }
      } else if (!$el.hasClass('error')) {
        $el.addClass('error');
        return this.$game.trigger('die', el);
      }
    },
    updateHints: function() {},
    eMark: function(e, el) {
      if (this.gameMode !== 'play') {
        return;
      }
      if (!this.mute) {
        this.assets.mark.play();
      }
      return $(el).toggleClass('mark', !this.isErasing);
    },
    ePaint: function(e, el) {
      var $el;
      $el = $(el);
      return $(el).toggleClass('paint', !this.isErasing);
    },
    eWin: function() {
      this.dragMode = null;
      if (!this.mute) {
        this.assets.win.play();
      }
      this.$win.text(this.getGolfScore());
      this.$win.show();
      return localStorage[this.title] = true;
    },
    eGridTouchmove: function(e) {
      var $el;
      e.preventDefault();
      $el = $(e.target);
      this.$game.trigger(this.dragMode, e.target);
      return this.assets.hoverSound.play();
    },
    eGridMouseover: function(e) {
      if (this.isDragging) {
        this.$game.trigger(this.dragMode, e.target);
      }
      if (!this.mute) {
        return this.assets.hoverSound.play();
      }
    },
    eGridMousedown: function(e) {
      var $el;
      e.preventDefault();
      $el = $(e.target);
      if (this.gameMode === 'play') {
        this.dragMode = e.which !== 1 ? 'mark' : 'break';
        if (this.dragMode === 'mark') {
          this.isErasing = $el.hasClass('mark');
        }
      } else {
        this.dragMode = 'paint';
        this.isErasing = $el.hasClass('paint');
      }
      this.isDragging = true;
      return this.$game.trigger(this.dragMode, e.target);
    }
  };

}).call(this);
